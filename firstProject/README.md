## Project root files

When you create a new Django project, it generates a directory with several files and subdirectories.

`Manage.py`: A command-line utility for managing various aspects of the project, such as running the development server, applying migrations, and creating new apps.

`<project-name>`: This directory carries the name you provided when you created the project. Inside, you'll find:

`(a) 'settings.py'`: This file holds the project's configuration settings, including database configurations, installed apps, middleware, and more.

`(b) 'urls.py'`: The urls.py files define the URL patterns and their corresponding views. These patterns determine which view should be called when a particular URL is accessed.

`(c) 'wsgi.py' and 'asgi.py':` This file is used for deploying the Django project on a WSGI server and ASGI server respectively.

`(d) **init**.py:`` An empty file indicating that the directory should be treated as a Python package.

`requirements.txt`

When you run pip freeze > requirements.txt , you're essentially creating a file named requirements.txt that contains a list of all the installed packages and their versions in the current environment. This file can be shared with others, allowing them to replicate your environment by running pip install -r requirements.txt.

## WSGI (Web Server Gateway Interface)

WSGI is designed for synchronous applications. It operates in a blocking, request-response model, which means it handles one request at a time in a linear fashion

Usage: WSGI is widely used in frameworks like Django (before Django 3.0), Flask, and Pyramid. It works well for apps where I/O (like database queries or file reads) is not heavily concurrent.
Limitations: WSGI struggles with real-time applications like WebSockets or long-polling connections because of its blocking nature.

## ASGI (Asynchronous Server Gateway Interface)

Asynchronous: ASGI is designed to handle both synchronous and asynchronous operations. It can manage long-lived connections and high-concurrency tasks, making it ideal for real-time apps like WebSockets, chat applications, or async API servers.

Usage: ASGI is used by frameworks like Django (3.0+ for async support), FastAPI, and Starlette. It provides support for WebSockets, HTTP2, and other modern protocols.
Flexibility: ASGI works well for both simple and complex use cases, enabling features like background tasks, WebSocket connections, and event-driven architectures.

### websocket

A WebSocket is a communication protocol that provides full-duplex (two-way) communication between a client (usually a web browser) and a server over a single, long-lived connection. Unlike traditional HTTP, where the client requests data from the server and the server responds once, WebSocket allows both the client and server to send messages to each other at any time.

## What is a Django App?

A Django app is a self-contained component within a Django project that performs a specific functionality or serves a particular purpose. Apps can be reused across projects and are designed to be modular, making it easier to maintain and extend Django projects.

To create a django app

```py
cd project-directory-name
django-admin startapp myapp
```

This command will create a new directory named myapp containing the necessary files and folders for your Django app.

```
myapp/
├── __init__.py
├── admin.py
├── apps.py
├── migrations/
│   └── __init__.py
├── models.py
├── tests.py
└── views.py
```

Let's take a closer look at each of these files and directories.

1. **ini**.py
   The **init**.py file is an empty file that tells Python to treat the myapp directory as a Python package. It's not necessary to add any code to this file unless you want to perform additional setup when the app is imported.

2. admin.py
   The admin.py file is where you can register models to be managed via Django's built-in admin interface. You can define custom admin views, filters, and actions for your models in this file.

3. apps.py
   The apps.py file defines the configuration for the Django app. It includes metadata such as the app name, verbose name, and app configuration class.

4. migrations/
   The migrations/ directory contains database migration files generated by Django's migration system. Migrations are used to manage changes to the database schema over time.

5. models.py
   The models.py file is where you define the data models for your Django app. Each model represents a database table, and you can define fields, relationships, and methods on the models to interact with the database.

6. tests.py
   The tests.py file is where you write tests for your Django app using Django's testing framework. Writing tests helps ensure the correctness and reliability of your application.

7. views.py
   The views.py file contains the view functions or classes that handle HTTP requests and return HTTP responses. Views are the heart of a Django app and define the logic for rendering templates, processing form submissions, and interacting with models.

## app

an app is a self-contained module that encapsulates a specific piece of functionality or a related set of features within a larger project. Each app is designed to do one thing and do it well, making it easier to organize and maintain your code. Here are some key points about Django apps:

## Views

a view is a function designed to handle a web request and return a web response. Each view function takes an HTTP Request object as its first parameter named `request`.

## 1. Creating URLS

`./home/views.py`
In views, we write our entire logic for page handling

```py
from django.shortcuts import render
from django.http import HttpResponse
# Create your views here.

def index(request):
    return HttpResponse("<h1>Hi, From django</h1>")

def about(request):
    return HttpResponse("<h2>Hi, from about page</h2>")

def contact(request):
    return HttpResponse("<h3>Hi, from contact page</h3>")
```

In `urls` file, we specify based on what path, which functions from views should be triggered.

`./firstProject/urls.py`

```py
from django.contrib import admin
from django.urls import path
from home.views import index, about, contact

urlpatterns = [
    path("",index,name="index"),
    path("about/",about,name="about"),
    path("contact/",contact,name="contact"),
    path('admin/', admin.site.urls),
]
```

But, the real world application does not contain simple texts, we need to return pages with lots of contents withing it.

To have pages, we create a folder `template` in `home` directory and will be creating pages there.

We use `render(request, page)` to render the given page.

render the whole page in `views.py`

```py
from django.shortcuts import render
from django.http import HttpResponse
# Create your views here.

def index(request):
    return render(request,"index.html")

def about(request):
    return render(request, "about.html")

def contact(request):
    return render(request, "contact.html")
```

## 2. Navigating to different routes

We can use `href` to navigate to different routes.

```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>django|home page</title>
	</head>
	<body>
		<nav style="padding: 4rem">
			<a href="/about">about</a>
			<a href="/contact">contact</a>
		</nav>
		<h1>Welcome to Hooshmandlab</h1>
	</body>
</html>
```

## 3. Dynamic routes

```html
<html lang="en">
	<head>
		<title>django|home page</title>
	</head>
	<body>
		<nav style="padding: 4rem">
			<a href="{%url 'about'%}">about</a>
			<a href="{%url 'contact'%}">contact</a>
		</nav>
	</body>
</html>
```

`<a href="{%url 'about'%}">about</a>`, we are saying that navigate the url based on the name, look for the then name about in urls and navigate to the function or page it rendering.
`path("about/",about,name="about"),`, name should match with what we write after `url` inside `<a>.`

## 4. Creating Dynamic Path

Creating dynamic URLs in Django involves using URL patterns to capture variable parts of a URL and pass them as parameters to your views.

```py
from django.contrib import admin
from django.urls import path
from home.views import index, about, contact, dynamic_url

urlpatterns = [
    path("",index,name="index"),
    path("<id>/", dynamic_url, name="dynamic_url"),
]
```

Now,lets pass the id to views and this is a must.

`./home/views.py`

```py
def dynamic_url(request, id):
    print(f"this is the id= {id}")
    return render(request, "dynamic_url.html")
```

`./home/templates/dynamic_url`

```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<nav style="padding: 4rem">
			<a href="{%url 'contact'%}">contact</a>
		</nav>
		<h1>From Dynamic URL</h1>
	</body>
</html>
```

## 5. context

by adding `context` inside render function, we can get access to all the objects that is passed to `context` inside template.

```py
def dynamic_url(request, id):
    print(f"this is the id= {id}")
    return render(request, "dynamic_url.html", context={"id":id, "name":"ahmad"})
```

```html
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Document</title>
	</head>
	<body>
		<section style="padding: 4rem">
			<nav style="padding: 4rem">
				<a href="{%url 'contact'%}">contact</a>
			</nav>
			<h1>From Dynamic URL</h1>
			<h1>hello {{name}}</h1>
			<h1>id: {{id}}</h1>
		</section>
	</body>
</html>
```

We can pass more than one parameter

```py
path("<id>/<name>/", dynamic_url, name="dynamic_url"),
def dynamic_url(request, id, name):
   print(f"this is the id= {id}")
   return render(request, "dynamic_url.html", context={"id":id, "name":name})

```

When we are navigating to these dynamic url, we have to pass the params we add in path, otherwise it will not work.

## 6. class based views vs function based views

### 1. function based

Function-Based Views in Django are Python functions that take a request and return a response. They are simple and easy to understand for small, straightforward views.

#### Pros:

Simplicity: Easy to understand, especially for small views.
Explicitness: Everything is laid out in a single function, making it easier to follow what is happening.
Flexibility: You can customize the request/response cycle freely without the need for class inheritance.

#### Cons:

Repetitive Code: For views that share logic (e.g., CRUD operations), you may end up writing repetitive code.
Limited Scalability: When the view becomes more complex, the function can grow large and become harder to manage.

```py
from django.http import HttpResponse

def my_view(request):
    return HttpResponse("Hello, world!")

```

### 2. class based views

Class-Based Views (CBVs)
Class-Based Views in Django are views organized as Python classes. They provide more structure and built-in functionality, allowing for code reuse and the use of object-oriented patterns.

#### Pros:

Reusability: You can create reusable and modular components by extending Django's generic views.
Readability: Logic can be broken down into methods (e.g., get(), post(), delete()), making it easier to organize code, especially for complex views.
Inheritance: You can take advantage of object-oriented programming (OOP), using inheritance to extend or modify existing views.
Built-in Generic Views: Django provides many built-in class-based views for common tasks like listing, creating, updating, and deleting objects (CRUD operations).

#### cons

Complexity: Initially more difficult to understand, especially for beginners.
Less Explicit: Some logic might be hidden in the class hierarchy, which may require diving into Django's documentation or source code to fully grasp what's happening.

```py
from django.http import HttpResponse
from django.views import View

class MyView(View):
    def get(self, request):
        return HttpResponse("Hello, world!")

```

## From Project

Without Quotes `(let secret = {{ secret_number }}`;):

Use this when secret_number is guaranteed to always be an integer.
It's a direct injection of the number.
With Quotes and parseInt() (let secret = `parseInt("{{ secret_number }}");)`:

Use this when secret_number might be empty, None, or a string representation of a number.
It's safer because it ensures the value is converted into a number, or NaN if invalid.

```sh
# To remove files from staged area
git rm -r --cached .
```
